# BP神经网络

## 一、BP神经网络

神经网络能很好地解决不同的机器学习问题。神经网络模型是许多逻辑单元按照不同层级组织起来的网络，每一层的输出变量都是下一层的输入变量。

![enter description here](http://pcv9xat5l.bkt.clouddn.com/BP神经网络/201883/1533281627046.png)


上图显示了人工神经网络是一个分层模型，逻辑上可以分为三层：

**输入层**：输入层接收特征向量 x

**输出层**：输出层产出最终的预测 h

**隐含层**：隐含层介于输入层与输出层之间，之所以称之为隐含层，是因为当中产生的值并不像输入层使用的样本矩阵 X或者输出层用到的标签矩阵 y 那样直接可见。

下面引入一些标记法来帮助描述模型：  

 `!$ a^{(j)}_{i} $`代表第j层的第i个激活单元。`!$ \theta^{(j)} $`代表从第 j 层映射到第 j+1 层时的权重的矩阵，例如`!$ \theta^{(1)} $`代表从第一层映射到第二层的权重的矩阵。其尺寸为：以第 j+1层的激活单元数量为行数，以第 j 层的激活单元数加一为列数的矩阵。例如：上图所示的神经网络中`!$ \theta^{(1)} $`的尺寸为 3*4。

对于上图所示的模型，激活单元和输出分别表达为：

 `!$ a^{(2)}_{1} = g( \theta^{(1)}_{10}x_0 +  \theta^{(1)}_{11}x_1 +  \theta^{(1)}_{12}x_2 +  \theta^{(1)}_{13}x_3 ) $`

`!$a^{(2)}_{2} = g( \theta^{(1)}_{20}x_0 +  \theta^{(1)}_{21}x_1 +  \theta^{(1)}_{22}x_2 +  \theta^{(1)}_{23}x_3 ) $`

 `!$a^{(2)}_{3} = g( \theta^{(1)}_{30}x_0 +  \theta^{(1)}_{31}x_1 +  \theta^{(1)}_{32}x_2 +  \theta^{(1)}_{33}x_3 ) $`

 `!$h_{\theta}{(x)} = g( \theta^{(2)}_{10}a^{2}_{0} +  \theta^{(2)}_{11}a^{2}_{1}  +  \theta^{(2)}_{12}a^{2}_{2}  +  \theta^{(2)}_{13}a^{2}_{3}  ) $`

下面用向量化的方法以上面的神经网络为例，试着计算第二层的值：

![enter description here](http://pcv9xat5l.bkt.clouddn.com/BP神经网络/201883/1533281626658.png)

![enter description here](http://pcv9xat5l.bkt.clouddn.com/BP神经网络/201883/1533281626656.png)
对于第三层的输入向量`!$ a^{2}_{0},a^{2}_{1},a^{2}_{2},a^{2}_{3}$`来说，可以将其看为`!$ x_{0},x_{1},x_{2},x_{3}$`的进化体，并且他们由x决定的，因为是梯度下降的，所以a是变化的，并且变得越来越厉害，所以这些更高级的特征值远比仅仅将 x次方厉害，也能更好的预测新数据。 这就是神经网络相比于逻辑回归和线性回归的优势。

**对于多类分类问题来说:**

![enter description here](http://pcv9xat5l.bkt.clouddn.com/BP神经网络/201883/1533281627365.png)



***

### 1.1 代价函数(Cost Function)

我们可将神经网络的分类定义为两种情况:二类分类和多类分类。

二类分类：`!$ S_{L} = 0,y = 0,y = 1$`

多类分类：`!$ S_{L} = k, y_{i} = 1表示分到第i类；(k>2)$`

![enter description here](http://pcv9xat5l.bkt.clouddn.com/BP神经网络/201883/1533281627369.png)

在神经网络中，我们可以有很多输出变量，我们的`!$h_{\theta}{(x)} $`是一个维度为K的向量，并且我们训练集中的因变量也是同样维度的一个向量，因此我们的代价函数会比逻辑回归更加复杂一些，为：`!$ h_{\theta}{(x)} \in R^{K}(h_{\theta}{(x)})_{i} = i^{th} output$`
$$
J(\theta) =- \frac{1}{m}[\sum_{i=1}^m\sum_{k=1}^ky^{(i)}logh_{\theta}{(x^{(i)})_{k}} + (1-y^{(i)}_{k})log(1-(h_{\theta}{(x^{(i)})})_{k})] + \frac{\lambda}{2m}\sum_{l=1}^{L-1}\sum_{i=1}^{s_{l}}\sum_{j=1}^{s_{l} +1}(\theta^{(l)}_{ji})^2
$$


我们希望通过代价函数来观察算法预测的结果与真实情况的误差有多大，唯一不同的是，对于每一行特征，我们都会给出K个预测，基本上我们可以利用循环，对每一行特征都预测K个不同结果，然后在利用循环在K个预测中选择可能性最高的一个，将其与y中的实际数据进行比较。

正则化的那一项只是排除了每一层`!$\theta_0$`后，每一层的$\theta$矩阵的和。最里层的循环j循环所有的行（由 $s_l$+1 层的激活单元数决定），循环i则循环所有的列，由该层（`!$ s_l$`层）的激活单元数所决定。即：`!$h_{\theta}{(x)}$`与真实值之间的距离为每个样本-每个类输出的加和，对参数进行**regularization**的**bias**项处理所有参数的平方和。

***

### 1.2前向传播算法(Forward Propagation)

![enter description here](http://pcv9xat5l.bkt.clouddn.com/BP神经网络/201883/1533281627365.png)

### 1.3反向传播算法(Backpropagation)

由于神经网络允许多个隐含层，即各层的神经元都会产出预测，因此，就不能直接利用传统回归问题的梯度下降法来最小化`!$J(\theta)$`，而需要逐层考虑预测误差，并且逐层优化。为此，在多层神经网络中，使用反向传播算法（Backpropagation Algorithm）来优化预测，首先定义各层的预测误差为向量 `!$ δ^{(l)} $`

![enter description here](http://pcv9xat5l.bkt.clouddn.com/BP神经网络/201883/1533281626504.png)

**训练过程：**

![enter description here](http://pcv9xat5l.bkt.clouddn.com/BP神经网络/201883/1533281626876.png)

### 1.4梯度检验(Gradient Checking)

当我们对一个较为复杂的模型（例如神经网络）使用梯度下降算法时，可能会存在一些不容易察觉的错误，意味着，虽然代价看上去在不断减小，但最终的结果可能并不是最优解。

为了避免这样的问题，我们采取一种叫做梯度的数值检验（**Numerical Gradient Checking**）方法。这种方法的思想是通过估计梯度值来检验我们计算的导数值是否真的是我们要求的。

对梯度的估计采用的方法是在代价函数上沿着切线的方向选择离两个非常近的点然后计算两个点的平均值用以估计梯度。即对于某个特定的$\theta$ ，我们计算出在`!$\theta - \epsilon$` 处和`!$\theta + \epsilon$`的代价值（是一个非常小的值，通常选取 0.001），然后求两个代价的平均，用以估计在 `!$\theta$` 处的代价值。

![enter description here](http://pcv9xat5l.bkt.clouddn.com/BP神经网络/201883/1533281626571.png)



当`!$\theta$`是一个向量时，我们则需要对偏导数进行检验。因为代价函数的偏导数检验只针对一个参数的改变进行检验，下面是一个只针对`!$\theta_1$`进行检验的示例：

![enter description here](http://pcv9xat5l.bkt.clouddn.com/BP神经网络/201883/1533281626569.png)

![enter description here](http://pcv9xat5l.bkt.clouddn.com/BP神经网络/201883/1533281626884.png)

如果上式成立，则证明网络中BP算法有效，此时关闭梯度校验算法（因为梯度的近似计算效率很慢），继续网络的训练过程。